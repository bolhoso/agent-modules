argument "receiver" {
	optional = false
}

argument "hashmod_shards" {
  default = 1
  optional = true
}
argument "shard_number" {
  default = 0
  optional = true
}
argument "node_name_filter" {
  default = ".*"
  optional = true
}
argument "scrape_interval"{
  default = "15s"
  optional = true
}

/********************************************
 * Discovery and Relabeling
 ********************************************/

discovery.kubernetes "pods" {
	role = "pod"
}

discovery.relabel "pods_autoscrape" {
  targets = discovery.kubernetes.pods.targets
  // only scrape ports with names ending in "metrics" OR `prometheus.io/scrape: true`
  rule {
    action = "keep"
    regex = ".*metrics;.*|.*;true"
    source_labels = ["__meta_kubernetes_pod_container_port_name","__meta_kubernetes_pod_annotation_prometheus_io_scrape"]
  }

  // if node_name_filter passed into this module, filter out pods from other nodes
  rule {
    action = "keep"
    source_labels = ["__meta_kubernetes_pod_node_name"]
    regex = argument.node_name_filter.value
  }

  // if prometheus.io/port is set, drop anything with non-matching container port

  // first make sure we have a consistent target port label
  rule {
    source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_port","__meta_kubernetes_pod_container_port_number"]
    regex = ";(\\d+)"
    replacement = "$1"
    target_label = "__meta_kubernetes_pod_annotation_prometheus_io_port"
  }
  // then drop anything where scrape port does not match container port
  rule{
    action = "keepequal"
    source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_port"]
    target_label = "__meta_kubernetes_pod_container_port_number"
  }
  // if pod specifies `prometheus.io/port`, use that instead of default
  rule {
    action = "replace"
    regex = "(.+?)(\\:\\d+)?;(\\d+)"
    replacement = "$1:$3"
    source_labels = ["__address__", "__meta_kubernetes_pod_annotation_prometheus_io_port"]
    target_label = "__address__"
  }

  // hashmod if needed
  rule {
    action = "hashmod"
    modulus = argument.hashmod_shards.value
    source_labels = ["__address__"]
    target_label = "__tmp_hash"
  }
  rule {
    action = "keep"
    regex = argument.shard_number.value
    source_labels = ["__tmp_hash"]
  }
  rule {
    action = "labeldrop"
    regex = "__tmp_hash"
  }

  // we need to find a usable application name from pod labels
  // this will be used in the job label
  // use (in-order) `name`, `app.kubernetes.io/name`, `k8s-app`, and `app` 
  rule {
    source_labels = ["__meta_kubernetes_pod_label_name"]
    target_label = "__meta_name_label"
  }
  rule {
    source_labels = ["__meta_name_label","__meta_kubernetes_pod_label_app_kubernetes_io_name"]
    target_label = "__meta_name_label"
    regex = ";(.+)"
  }
  rule {
    source_labels = ["__meta_name_label","__meta_kubernetes_pod_label_k8s_app"]
    target_label = "__meta_name_label"
    regex = ";(.+)"
  }
  rule {
    source_labels = ["__meta_name_label","__meta_kubernetes_pod_label_app"]
    target_label = "__meta_name_label"
    regex = ";(.+)"
  }
  // finally drop anything without any of the above labels
  rule {
    action = "keep"
    source_labels = ["__meta_name_label"]
  }
  // drop non-running pods
  rule {
    action = "drop"
    regex = "Succeeded|Failed"
    source_labels = ["__meta_kubernetes_pod_phase"]
  }
  // drop any pod with annotation `prometheus.io/scrape: false`
  rule {
    action = "drop"
    regex = "false"
    source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_scrape"]
  }
  // replace scheme if pod has `prometheus.io/scheme: https`
  rule {
    action = "replace"
    regex = "(https?)"
    replacement = "$1"
    source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_scheme"]
    target_label = "__scheme__"
  }
  // if pod sets `prometheus.io/path`, use that as the metrics path
  rule {
    action = "replace"
    regex = "(.+)"
    replacement = "$1"
    source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_path"]
    target_label = "__metrics_path__"
  }
  
  rule {
    action = "labelmap"
    regex = "__meta_kubernetes_pod_annotation_prometheus_io_param_(.+)"
    replacement = "__param_$1"
  }
  rule {
    action = "labelmap"
    regex = "__meta_kubernetes_pod_label_prometheus_io_label_(.+)"
  }
  rule {
    action = "labelmap"
    regex = "__meta_kubernetes_pod_annotation_prometheus_io_label_(.+)"
  }
  // set job to namespace/ name label (as discovered above)
  rule {
    action = "replace"
    replacement = "$1"
    separator = "/"
    source_labels = ["__meta_kubernetes_namespace", "__meta_name_label"]
    target_label = "job"
  }
  // set namespace, pod, and container labels on resulting metrics
  rule {
    action = "replace"
    source_labels = ["__meta_kubernetes_namespace"]
    target_label = "namespace"
  }
  rule {
    action = "replace"
    source_labels = ["__meta_kubernetes_pod_name"]
    target_label = "pod"
  }
  rule {
    action = "replace"
    source_labels = ["__meta_kubernetes_pod_container_name"]
    target_label = "container"
  }
  // make sure we always have a unique instance label
  rule {
    action = "replace"
    separator = ":"
    source_labels = ["__meta_kubernetes_pod_name", "__meta_kubernetes_pod_container_name", "__meta_kubernetes_pod_container_port_name"]
    target_label = "instance"
  }
}

prometheus.scrape "scraper" {
  targets = discovery.relabel.pods_autoscrape.output
  forward_to = [argument.receiver.value]
  scrape_interval = argument.scrape_interval.value
}
